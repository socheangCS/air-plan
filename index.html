<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Plane vs Enemies - Mobile Controls</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Sky blue */
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: #333;
            touch-action: none; /* Prevent default touch actions like pinch-zoom on body */
        }

        #game-area {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: crosshair;
        }

        #plane {
            position: absolute;
            font-size: 40px; /* Adjust if needed for visibility */
            transform-origin: center center;
            user-select: none;
            z-index: 10;
        }

        .projectile {
            position: absolute;
            width: 8px;
            height: 15px;
            background-color: red;
            border-radius: 4px;
            box-shadow: 0 0 5px yellow;
            user-select: none;
            z-index: 5;
        }

        .enemy {
            position: absolute;
            font-size: 30px;
            user-select: none;
            z-index: 1;
        }

        .instructions { /* Renamed from .controls to avoid conflict */
            position: fixed;
            top: 10px; /* Moved to top */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.6);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            text-align: center;
            z-index: 100;
        }
        .instructions p {
            margin: 2px 0;
        }
        #score-display {
            font-weight: bold;
            font-size: 1.1em;
        }

        /* --- Mobile Controls --- */
        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto; /* Adjust height as needed, e.g., 150px */
            display: flex;
            justify-content: space-between;
            align-items: flex-end; /* Align buttons to bottom */
            padding: 20px;
            box-sizing: border-box;
            z-index: 90;
            pointer-events: none; /* Container itself doesn't block touches */
        }

        #mobile-controls button {
            background-color: rgba(255, 255, 255, 0.4);
            border: 2px solid rgba(0, 0, 0, 0.3);
            color: rgba(0,0,0,0.7);
            font-size: 28px; /* Larger font for button symbols */
            font-weight: bold;
            border-radius: 50%; /* Circular buttons */
            width: 65px;
            height: 65px;
            margin: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none; /* Prevent text selection on tap */
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent; /* No blue highlight on tap */
            pointer-events: auto; /* Buttons themselves are touchable */
            touch-action: manipulation; /* Optimize for button-like interaction */
        }
        #mobile-controls button:active {
            background-color: rgba(200, 200, 200, 0.6);
        }


        .d-pad {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 5px;
            width: 200px; /* Approx 3x button width + 2x gap */
            height: 200px;
        }
        .d-pad-up { grid-area: up; }
        .d-pad-left { grid-area: left; }
        .d-pad-right { grid-area: right; }
        .d-pad-down { grid-area: down; }

        .action-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #touch-fire {
             width: 80px; /* Fire button larger */
             height: 80px;
             font-size: 36px;
        }

        /* Hide mobile controls on non-touch devices by default (optional, JS can also do this) */
        /* @media (pointer: fine) {
            #mobile-controls {
                display: none;
            }
        } */
    </style>
</head>
<body>
    <div id="game-area">
        <div id="plane">âœˆ</div>
    </div>

    <div class="instructions">
        <p>Desktop: Arrow Keys & Space</p>
        <p>Mobile: On-Screen Buttons</p>
        <p id="score-display">Score: 0</p>
    </div>

    <div id="mobile-controls">
        <div class="d-pad">
            <button id="touch-up" class="d-pad-btn d-pad-up">â–²</button>
            <button id="touch-left" class="d-pad-btn d-pad-left">â—€</button>
            <button id="touch-right" class="d-pad-btn d-pad-right">â–¶</button>
            <button id="touch-down" class="d-pad-btn d-pad-down">â–¼</button>
        </div>
        <div class="action-buttons">
            <button id="touch-fire" class="action-btn">ðŸ’¥</button>
        </div>
    </div>

    <script>
        const gameArea = document.getElementById('game-area');
        const plane = document.getElementById('plane');
        const scoreDisplay = document.getElementById('score-display');

        // Plane State
        let planeX = window.innerWidth / 2;
        let planeY = window.innerHeight / 2;
        let planeAngle = -90;
        let planeWidth = 40;
        let planeHeight = 40;

        // Control & Physics
        let currentSpeed = 0;
        const maxSpeed = 5;
        const acceleration = 0.1;
        const deceleration = 0.03;
        const brakePower = 0.15;
        const turnSpeed = 3.5;
        const keysPressed = {};
        const touchControls = { // For mobile touch buttons
            left: false,
            right: false,
            up: false,
            down: false
        };

        // Projectiles
        const projectiles = [];
        const projectileSpeed = 10;
        const projectileWidth = 8;
        const projectileHeight = 15;

        // Enemies
        const enemies = [];
        const enemyTypes = ['ðŸ‘½', 'ðŸ‘¾', 'ðŸ›¸', 'ðŸ’£', 'ðŸ’€'];
        const maxEnemies = 5;
        let lastEnemySpawnTime = 0;
        const enemySpawnCooldown = 2500;
        const enemyBaseSpeed = 1;
        const enemySize = 30;

        // Game State
        let score = 0;
        let gameOver = false;

        // --- Event Listeners for Keyboard Controls ---
        window.addEventListener('keydown', (e) => {
            if (gameOver) return;
            keysPressed[e.key] = true;
            if (e.key.startsWith('Arrow') || e.key === ' ') {
                e.preventDefault();
            }
            if (e.key === ' ') {
                fireProjectile();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (gameOver) return;
            keysPressed[e.key] = false;
        });

        // --- Event Listeners for Touch Controls ---
        function setupTouchButton(buttonId, controlKey) {
            const button = document.getElementById(buttonId);
            if (button) {
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent default touch actions (scroll, zoom)
                    if (gameOver) return;
                    touchControls[controlKey] = true;
                }, { passive: false }); // passive: false needed for preventDefault

                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (gameOver) return;
                    touchControls[controlKey] = false;
                }, { passive: false });

                button.addEventListener('touchcancel', (e) => { // Handle if touch is interrupted
                    e.preventDefault();
                    if (gameOver) return;
                    touchControls[controlKey] = false;
                }, { passive: false });
            }
        }

        const fireButton = document.getElementById('touch-fire');
        if (fireButton) {
            fireButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameOver) return;
                fireProjectile();
            }, { passive: false });
        }

        // --- Plane Logic (integrates keyboard and touch) ---
        function updatePlanePosition() {
            if (gameOver) return;

            // Rotation
            if (keysPressed['ArrowLeft'] || touchControls.left) planeAngle -= turnSpeed;
            if (keysPressed['ArrowRight'] || touchControls.right) planeAngle += turnSpeed;
            planeAngle = (planeAngle + 360) % 360;

            // Speed
            if (keysPressed['ArrowUp'] || touchControls.up) {
                currentSpeed += acceleration;
                if (currentSpeed > maxSpeed) currentSpeed = maxSpeed;
            } else if (keysPressed['ArrowDown'] || touchControls.down) {
                currentSpeed -= brakePower;
                if (currentSpeed < 0) currentSpeed = 0;
            } else {
                if (currentSpeed > 0) {
                    currentSpeed -= deceleration;
                    if (currentSpeed < 0) currentSpeed = 0;
                }
            }

            const rad = planeAngle * (Math.PI / 180);
            planeX += Math.cos(rad) * currentSpeed;
            planeY += Math.sin(rad) * currentSpeed;

            if (planeX > window.innerWidth + planeWidth / 2) planeX = -planeWidth / 2;
            if (planeX < -planeWidth / 2) planeX = window.innerWidth + planeWidth / 2;
            if (planeY > window.innerHeight + planeHeight / 2) planeY = -planeHeight / 2;
            if (planeY < -planeHeight / 2) planeY = window.innerHeight + planeHeight / 2;

            plane.style.left = `${planeX - planeWidth / 2}px`;
            plane.style.top = `${planeY - planeHeight / 2}px`;
            plane.style.transform = `rotate(${planeAngle}deg)`;
        }

        // --- Projectile Logic ---
        function fireProjectile() {
            if (gameOver) return;
            const projectile = document.createElement('div');
            projectile.classList.add('projectile');
            gameArea.appendChild(projectile);

            const rad = planeAngle * (Math.PI / 180);
            const distanceFromCenterToNoseTip = (planeWidth / 2) + 7;
            const actualNoseOffsetX = distanceFromCenterToNoseTip * Math.cos(rad);
            const actualNoseOffsetY = distanceFromCenterToNoseTip * Math.sin(rad);

            let pX = planeX + actualNoseOffsetX;
            let pY = planeY + actualNoseOffsetY;

            projectile.style.left = `${pX - projectileWidth / 2}px`;
            projectile.style.top = `${pY - projectileHeight / 2}px`;
            projectile.style.transform = `rotate(${planeAngle}deg)`;

            projectiles.push({
                element: projectile, x: pX, y: pY,
                angleRad: rad, width: projectileWidth, height: projectileHeight
            });
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += Math.cos(p.angleRad) * projectileSpeed;
                p.y += Math.sin(p.angleRad) * projectileSpeed;

                p.element.style.left = `${p.x - p.width / 2}px`;
                p.element.style.top = `${p.y - p.height / 2}px`;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(p, enemy)) {
                        destroyEnemy(j);
                        p.element.remove();
                        projectiles.splice(i, 1);
                        score += 10;
                        updateScoreDisplay();
                        break;
                    }
                }

                if (projectiles.includes(p) && (p.x < -p.width || p.x > window.innerWidth + p.width || p.y < -p.height || p.y > window.innerHeight + p.height)) {
                    p.element.remove();
                    projectiles.splice(i, 1);
                }
            }
        }

        // --- Enemy Logic ---
        function spawnEnemy() {
            if (gameOver || enemies.length >= maxEnemies) return;
            const enemy = document.createElement('div');
            enemy.classList.add('enemy');
            enemy.textContent = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            gameArea.appendChild(enemy);

            let ex, ey;
            const edge = Math.floor(Math.random() * 4);
            switch (edge) {
                case 0: ex = Math.random() * window.innerWidth; ey = -enemySize; break;
                case 1: ex = window.innerWidth + enemySize; ey = Math.random() * window.innerHeight; break;
                case 2: ex = Math.random() * window.innerWidth; ey = window.innerHeight + enemySize; break;
                case 3: ex = -enemySize; ey = Math.random() * window.innerHeight; break;
            }

            const targetX = window.innerWidth / 2 + (Math.random() - 0.5) * (window.innerWidth / 3);
            const targetY = window.innerHeight / 2 + (Math.random() - 0.5) * (window.innerHeight / 3);
            const angleToTarget = Math.atan2(targetY - ey, targetX - ex);

            enemies.push({
                element: enemy, x: ex, y: ey,
                dx: Math.cos(angleToTarget) * enemyBaseSpeed * (0.8 + Math.random() * 0.4),
                dy: Math.sin(angleToTarget) * enemyBaseSpeed * (0.8 + Math.random() * 0.4),
                width: enemySize, height: enemySize,
            });
            lastEnemySpawnTime = Date.now();
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.x += e.dx;
                e.y += e.dy;
                e.element.style.left = `${e.x - e.width / 2}px`;
                e.element.style.top = `${e.y - e.height / 2}px`;
                if (e.x < -e.width * 2 || e.x > window.innerWidth + e.width * 2 ||
                    e.y < -e.height * 2 || e.y > window.innerHeight + e.height * 2) {
                    destroyEnemy(i);
                }
            }
        }

        function destroyEnemy(index) {
            if (enemies[index]) {
                enemies[index].element.remove();
                enemies.splice(index, 1);
            }
        }

        // --- Utility Functions ---
        function checkCollision(rect1, rect2) {
            return (
                rect1.x - rect1.width / 2 < rect2.x + rect2.width / 2 &&
                rect1.x + rect1.width / 2 > rect2.x - rect2.width / 2 &&
                rect1.y - rect1.height / 2 < rect2.y + rect2.height / 2 &&
                rect1.y + rect1.height / 2 > rect2.y - rect2.height / 2
            );
        }

        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score}`;
        }

        // --- Game Loop ---
        function gameLoop(timestamp) {
            if (gameOver) return;
            updatePlanePosition();
            updateProjectiles();
            updateEnemies();
            if (Date.now() - lastEnemySpawnTime > enemySpawnCooldown) {
                spawnEnemy();
            }
            requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            planeWidth = plane.offsetWidth || 40;
            planeHeight = plane.offsetHeight || 40;
            planeX = window.innerWidth / 2;
            planeY = window.innerHeight / 2;
            plane.style.left = `${planeX - planeWidth / 2}px`;
            plane.style.top = `${planeY - planeHeight / 2}px`;
            plane.style.transform = `rotate(${planeAngle}deg)`;

            updateScoreDisplay();
            spawnEnemy();
            lastEnemySpawnTime = Date.now();

            gameArea.addEventListener('click', (e) => {
                // Only fire if click is not on a mobile control button
                if (!e.target.closest('#mobile-controls')) {
                    fireProjectile();
                }
            });

            // Setup touch controls
            setupTouchButton('touch-left', 'left');
            setupTouchButton('touch-right', 'right');
            setupTouchButton('touch-up', 'up');
            setupTouchButton('touch-down', 'down');

            // Conditionally show mobile controls (simple check)
            const mobileControlsElement = document.getElementById('mobile-controls');
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                // It's likely a touch device
            } else {
                // Likely not a touch device, hide mobile controls
                 if(mobileControlsElement) mobileControlsElement.style.display = 'none';
            }


            requestAnimationFrame(gameLoop);
        });

        window.addEventListener('resize', () => {
            if (plane.offsetWidth) planeWidth = plane.offsetWidth;
            if (plane.offsetHeight) planeHeight = plane.offsetHeight;
            // Could also reset plane position on resize if desired
            // planeX = window.innerWidth / 2;
            // planeY = window.innerHeight / 2;
        });
    </script>
</body>
</html>